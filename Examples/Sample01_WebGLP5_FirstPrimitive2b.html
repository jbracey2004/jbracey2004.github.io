<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <title>Portfolio - P5 WebGL Primitives</title>
		<script src="../libref/p5/p5.min.js"></script>
        <script src="../libref/p5/p5.utilMatrix.js"></script>
        <script>
			var canvasMain;
			var pt = 0;
			var ct = 0;
			var objTrans = [];

            function setup() {
                var p5objCanvas = createCanvas(windowWidth, windowHeight, WEBGL);
				canvasMain = p5objCanvas.elt;
				canvasMain.style["touch-action"] = "none";
				pixelDensity(1);
				for(var i = 0; i < 6; i++) { objTrans.push(new p5.Matrix());}
            }

            function draw() {
				var tn = new Date(Date.now()).getTime()*0.001;
				if (pt == 0) { pt = tn; }
				var t = tn - pt;
				ct += t;

				var beta = radians(rotationX);
				var gamma = radians(rotationY);
				var prevBeta = radians(pRotationX);
				var prevGamma = radians(pRotationY);
				var deltaBeta = beta - prevBeta;
				var deltaGamma = gamma - prevGamma;

                background(64);
				var sw = (1/10) * ((windowWidth ** 2 + windowHeight ** 2) ** 0.5);
				var sp = sw * 2;
				normalMaterial();
				
				var tmpGamma, tmpBeta;
				if(windowWidth > windowHeight) {
					tmpGamma = beta;
					tmpBeta = gamma;
				} else {
					tmpGamma = gamma;
					tmpBeta = beta;
				}
					
				for(var vRot of objTrans) {
					var matxTmp = new p5.Matrix();
					matxTmp.rotateY(tmpGamma * 16 * t);
					matxTmp.rotateX(-tmpBeta * 16 * t);
					matxTmp = vRot.mult(matxTmp.copy());
					vRot = matxTmp.copy();
				}

				push();
				translate(-sp, -0.5 * sp);
				applyTransMatrix(objTrans[0]);
				//rotateX(TAU * -(1 / 16));
				//rotateY(ct*TAU*0.5);
				box(sw);
				pop();

				push();
				translate(0, -0.5 * sp);
				applyTransMatrix(objTrans[1]);
				//rotateY(TAU * (1 / 16));
				//rotateX(ct * TAU * 0.25);
				cone(sw*0.8,sw*1.2);
				pop();

				push();
				translate(sp, -0.5 * sp);
				applyTransMatrix(objTrans[2]);
				//rotateX(ct * TAU * 0.7);
				//rotateY(ct * TAU * 0.25);
				ellipsoid(sw * 0.8, sw*0.9, sw * 0.7);
				pop();

				push();
				translate(-sp, 0.5 * sp);
				applyTransMatrix(objTrans[3]);
				//rotateX(ct * TAU * ( 1 / 16));
				//rotateY(ct * TAU * -0.25);
				torus(sw * 0.6, sw * 0.25);
				pop();

				push();
				translate(0, 0.5 * sp);
				applyTransMatrix(objTrans[4]);
				//rotateY(ct * TAU * (1 / 2));
				//rotateZ(ct * TAU * (1 / 26));
				cylinder(sw*0.5, sw*1.2);
				pop();

				push();
				translate(sp, 0.5 * sp);
				applyTransMatrix(objTrans[5]);
				//rotateX(ct * TAU * (1 / 7));
				//rotateY(ct * TAU * (1 / 2));
				//rotateZ(ct * TAU * (1 / 26));
				box(sw, sw * 0.75, sw * 0.5);
				pop();

				push();
				var areaGB = {X:0.5, Y:0.125, W:windowWidth*0.125, H:windowHeight*0.125}
				if(windowWidth > windowHeight) {var tmp = areaGB.X; areaGB.X = areaGB.Y; areaGB.Y = tmp;}
				translate(-windowWidth*0.5, -windowHeight*0.5);
				push();
				translate(areaGB.X*windowWidth, areaGB.Y*windowHeight);
				fill("#00000080");
				noStroke();
				ellipse(0, 0, areaGB.W, areaGB.H);
				fill("#00008080");
				var tmpGBPos = {X:tmpGamma, Y:tmpBeta};
				var tmpGBDistInv = 1 / ((tmpGBPos.X ** 2 + tmpGBPos.Y ** 2) ** 0.5);
				tmpGBPos.X *= areaGB.W;
				tmpGBPos.Y *= areaGB.H;
				ellipse(tmpGBPos.X*0.5, tmpGBPos.Y*0.5, areaGB.W*0.5, areaGB.H*0.5);
				pop();
				pop();

				pt = tn;
            }

			function applyTransMatrix(matx) {
				var matxTmp = matx.copy();
				matxTmp = matxTmp.mult(_renderer.uMVMatrix.copy());
				_renderer.uMVMatrix = matxTmp.copy();
			}

            function windowResized() {
                resizeCanvas(windowWidth, windowHeight);
                console.log({
                    Width: windowWidth,
                    Height: windowHeight
                });
            }
        </script>

    </head>

    <body style="margin: 0; display: flex; justify-content: center; align-items: center; position: relative;">
    </body>

</html>